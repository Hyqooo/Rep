#include <stdio.h>
#include <stdlib.h>

/*
	Функции - это некоторый блок в программе, который может выполнять
	какие-то заданные в нем действия. Применяются для решения подзадач
	в рамках какой-то большой задачи. Написание функций позволяет избежать
	дублирования кода, так же облегчается чтение и понимание программы.
*/

/*
	Общая структрура определения функции:

	тип_возвращаемого_значения  имя_фукнции  (формальные_параметры)
	{
		тело_функции
	}

Теперь отдельно по каждому пункту:

	1) Тип_возвращаемого_значения
		Задает значение какого типа вернет функция после своей работы.
		Например: int, char, double, void.
		int, char, double - выполняет какие-то операции и возвращает указанный тип.
		void - пустое, не возвращает ничего, просто выполняет какие-то действия.

	2) Имя_Функции
		Может быть любым, правила такие же как у переменных.

	3) формальные параметры
		Параметры которые передаются в функцию и с которыми она будет работать
		При этом нужно указывать их тип и имя, они считаются локальными переменными
		видными только внутри самой функции.
		Например: (int a, int b)

	4) Тело функции
		Блок, внутри которого непосредственно магия и происходит.
	
		Замечание: фукнции не исполняются сами по себе, код внутри их выполняется
		только после вызова из фукнции main. Возможно, конечно, и вызов из другой фукнции,
		но та в свою очередь должна быть вызвана из main.
*/




/*
	Лучше прочесть после первой описанной функции.

	Прототип описывается следующим образом:
	
		тип_возвращаемого_значения  имя_фукнции  (параметры);

	1) Тип и имя должны в точности соответствовать фукнции, в которой написано 
	определение.
	2) Параметры можно передавать без имен, указывая лишь их тип.
	3) Нет тела фукнции, поэтому после закрывающей скобки параметров идет точка с запятой.
	
	Прототипы функции необходимы для предотвращения ошибок.
	Допустим, у нас есть функция и мы вызываем ее где-то в main, но при этом
	ее определение написано где-то ниже и оно еще не встретилось компилятору,
	так как компилятор понятия не имеет что это за фукнция он автоматически 
	описывает ее как возвращающую int и ничего не получающую в качестве аргументов, 
	поэтому в дальнейшем компилятор не станет проверять правильность типов
	и количества аргументов при вызове, что может оказаться в проблемой,
	на всякий случай перестраховаться и написать прототип, чтобы потом не выяснилось,
	что три часа не понимаешь почему программа работает как-то не так, а оказывается 
	переданы параметры неправильного типа. 
*/

// Прототипы.
int Summation(int, int);
int ChangeValue(int);
void RandomNumbersGenerator(int [5][5]);
void DisplayMatrix(int [5][5], char);
void ChangeRealValue(int*);


void main(){

	/*
		Чтобы посмотреть работу примеров можно комментить целые регионы,
		так как программа содержит несколько отдельных программ вместе.
	*/


#pragma region Summation

	int a, b, result;
	
	printf("Input a:\n");
	scanf("%d", &a);
	printf("Input b:\n");
	scanf("%d", &b);

	 
	// Подобный способ удобен, если функция возвращает значение,
	// которое можно проанализировать, например: 0 - false, 1 - true.
	// Далее будет дана практическая реализация.

	result = Summation(a, b);

	printf("\nresult = %d\n", result);

#pragma endregion



#pragma region Random	
	
	int matrix[5][5];
	RandomNumbersGenerator(matrix);
	DisplayMatrix(matrix, 'A');

#pragma endregion



#pragma region ChangeValue
	
	int a = 3;

	// В данном примере переменная а передается в функцию и ее значение
	// выводится на экран
	ChangeValue(a);
	printf("%d\n", a);

	//	В данном примере есть переменная а, адрес которой передается в фукнцию,
	//	затем ее значение выводится на экран.
	ChangeRealValue(&a);
	printf("%d\n", a);

#pragma endregion

	
}

/* 
   Функция сложения, на вход даем два параметра a и b
   на выходе выводит результат сложения.
*/
int Summation(int a, int b){
	// Локальная переменная, видна только внутри функции.
	int res;

	// Присваиваем ей значение суммы.
	res = a + b;

	// Возвращаем значение из фукнции с помощью return.
	return res;
}

/*	 
	Функция, заполняющая массив случайными числами, на входе матрица размера 5x5.
	Эта функция не возвращает никаких значений,то есть операция: 
		result = (вызов фукнции типа void); - недопустима.


	Замечание: функции могут принимать любые параметры, в данном случае
	передается указатель, хотя явно он не указан, поэтому стоит внимательно
	следить за тем, что передается в функцию.
*/
void RandomNumbersGenerator(int matrix[5][5]){
	int r;
	for (int i = 0; i < 5; i++){
		for (int j = 0; j < 5; j++){
			r = rand() % 10;
			matrix[i][j] = r;
		}
	}
}

/* 
	Еще один пример - вывод матрицы на экран.

	На входе матрица 5х5 и имя, которое будет напечатано.
*/
void DisplayMatrix(int mat[5][5], char name){
	printf("Matrix %c:\n", name);
	for (int i = 0; i < 5; i++){
		for (int j = 0; j < 5; j++){
			printf("%i ", mat[i][j]);
		}
		printf("\n");
	}
}

/*
	Хотя казалось бы здесь мы присвоили переменной а значение 20,
	и вроде бы вернули его, значение исходной переменной не изменилось.

	Замечание: это так называемая передача аргументов по значению, то есть 
	передается копия исходной переменной, которая никак не может повлиять на исходную 
	переменную.
*/
int ChangeValue(int a){
	a = 20;
	return a;
}

/*
	Реализация той же самой задачи, здесь мы можем использовать тип 
	void, потому что нам не нужно, чтобы эта функция что-то возвращала.

	Замечание: здесь передача аргументов по ссылке, то есть передается
	адрес в памяти на эту переменную и мы можем работать непосредственно с ней.
*/
void ChangeRealValue(int *a){
	*a = 20;
}
